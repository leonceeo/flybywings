package fbw.serverpush;

import java.io.IOException;
import java.util.Set;
import javax.servlet.http.HttpSession;
import org.atmosphere.cpr.Broadcaster;
import org.atmosphere.cpr.BroadcasterFactory;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.wings.LowLevelEventListener;
import org.wings.ReloadManager;
import org.wings.SComponent;
import org.wings.SForm;
import org.wings.SFrame;
import org.wings.io.StringBuilderDevice;
import org.wings.resource.UpdateResource;
import org.wings.session.Session;
import org.wings.session.SessionManager;

/**
 * A Pushable encapsulates the logic that should be executed by a server push
 * and emulates the surrounding actions of the wingS framework that normally
 * apply for a client initiated request-response-cycle.
 *
 * Because such push logic is typically processed by a separate thread on the
 * server and not within a servlet thread handling a default client request,
 * each Pushable extends the Runnable interface.
 *
 * As a mandatory dependency a valid wingS session must be handed over at
 * creation time. Otherwise the Pushable won't know in which context the push
 * logic should be executed. If no session is explicitly given, e.g. the default
 * constructor is called, the Pushable requests the current session from the
 * SessionManager. In case the latter has no current session because the current
 * thread has not been assigned a session via the thread local pattern (this is
 * usually done in SessionServlet upon each client request), the creation of the
 * Pushable fails.
 *
 * The actual push logic is of course application-dependant and must therefore
 * be provided by the application developer via overriding the abstract push()
 * method. Executing this logic entails state changes in the server which need
 * to be transferred to the client in form of partial updates. In order to
 * collect and serialize these updates a Pushable utilizes the UpdateResouce and
 * the ReloadManager of wingS. The final response message and its properties are
 * then encapsulated in a Pushable.Message and handed over to the Atmosphere
 * framework. This is done by invoking the broadcast() method of the broadcaster
 * associated with the Pushable's session and ultimately results in the
 * ServerPushHandler's onMessage() method being called. As the final step, the
 * latter will write back the response message generated by the Pushable to the
 * suspended AtmosphereResource or AtmosphereResponse respectively. On the
 * client this response message will be processed by a dedicated piece of
 * JavaScript which extracts each partial update within and applies it to the
 * according HTML UI component. In fact, a partial update is nothing more than a
 * JavaScript code fragment, usually a method call, which can simply be
 * evaluated on the client side it by means of window.eval().
 *
 * @author Stephan Schuster
 */
public abstract class Pushable implements Runnable {

    private static final Logger LOG = LoggerFactory.getLogger(Pushable.class);
    private final Session session;
    private final HttpSession httpSession;
    private boolean preventFormEvents;
    private boolean preventEpochUpdates;

    public Pushable() {
        this(null);
    }

    public Pushable(Session session) {
        if (session == null) {
            // In case no session is provided, we try to get
            // the current session from the SessionManager
            session = SessionManager.getSession();
            if (session == null) {
                // Fail if we've got no session at this point
                throw new IllegalStateException("No session available");
            }
        }
        // Assign the wingS session and the according HTTP session to
        // private fields so that we can retrieve it later on when the
        // Pushable is executed in another thread and the session is
        // not attached to the SessionManager anymore (ThreadLocal).
        this.session = session;
        this.httpSession = session.getServletRequest().getSession(false);
    }

    public Pushable preventFormEvents() {
        this.preventFormEvents = true;
        return this;
    }

    public Pushable preventEpochUpdates() {
        this.preventEpochUpdates = true;
        return this;
    }

    @Override
    public final void run() {
        try {
            if (SessionManager.getSession() != null) {
                // In case a session is attached to the SessionManager
                // we assume that we are running in the default client
                // initiated request-response-cycle (where the session
                // is attached to the current servlet thread by the so
                // called SessionServlet via the ThreadLocal pattern).
                runInClientRequestCycle();
            } else {
                // If no session is attached to the SessionManager we
                // are definitely running outside of the default client
                // initiated request-response-cycle. In order to make
                // things work anyway, we need to do two things: First,
                // we need to synchronize on the HTTP session, exactly
                // as it is done for normal requests in WingServlet.
                // Second, we need to attach the Pushable's session to
                // the current thread since we want the external methods
                // we call (e.g. UpdateResource.write()) to be able to
                // retrieve the "current session" via SessionManager.
                synchronized (httpSession) {
                    try {
                        SessionManager.setSession(session);
                        runInServerPushThread();
                    } finally {
                        SessionManager.removeSession();
                    }
                }
            }
        } catch (Throwable ex) {
            LOG.error("Error while running pushable", ex);
        }
    }

    /**
     * This method needs to be overridden by the application developer with the
     * desired server push logic or state changes respectively.
     */
    protected abstract void push();

    private void runInClientRequestCycle() throws Exception {
        // If - for whatever reason - the Pushable is run in a client
        // request cycle, we simply execute the provided application
        // logic. There is no need for a real server push here because
        // the state changes entailed by push() are transferred back
        // to the client during the default response mechanism anyway.
        push();
    }

    private void runInServerPushThread() throws Exception {
        // In case we run in a server push thread we need to emulate
        // the main actions of the wingS framework that normally apply
        // for the default client initiated request-response-cycle.
        // Basically this is the logic found in the SessionServlet but
        // stripped down to the bare minimum. What we do in detail is:

        // Retrieve the session's reload manager and switch to update mode
        // so that further state changes trigger partial component updates.
        ReloadManager reloadManager = session.getReloadManager();
        reloadManager.setUpdateMode(true);

        push(); // Execute the actual server push logic --> state changes

        if (!preventFormEvents) {
            // Emulate form events for all components that have been marked
            // "dirty" as a result of executing the server push logic above
            SForm.clearArmedComponents();
            for (SComponent dirtyComponent : reloadManager.getDirtyComponents()) {
                if (dirtyComponent instanceof LowLevelEventListener) {
                    SForm.addArmedComponent((LowLevelEventListener) dirtyComponent);
                }
            }
            SForm.fireEvents();
        }

        // Notify code generators. Looking at the current wingS sources this
        // is actually not needed anymore. However, since it is done within
        // SessionServlet, we'll do it here just for the sake of completeness.
        reloadManager.notifyCGs();

        if (!preventEpochUpdates) {
            // Invalidate frames containing dirty components. In fact, this
            // increments the event epoch of these frames on server side and
            // entails the according partial epoch update for the client side.
            reloadManager.invalidateFrames();
        }

        // Generate the response message in the default wingS-specific format.
        // This is a standalone XML fragment consisting of various <update>-
        // nodes each of which contain a valid JavaScript fragment that needs
        // to be evaluated on the client in order to update the user interface.
        Message message = getUpdateMessage();
        if (message != null) {
            // If we've got a valid response message we need to actively push
            // it to the client by means of the session broadcaster we created
            // and associated beforehand in ServerPushHandler.onOpen().
            String broadcasterId = httpSession.getId();
            LOG.debug("Invoking broadcaster: {}", broadcasterId);
            // Just lookup the according session broadcaster (do NOT create it)
            Broadcaster broadcaster = BroadcasterFactory.getDefault().lookup(broadcasterId);
            if (broadcaster == null) {
                // Fail if we've got no session broadcaster at this point
                throw new IllegalStateException("No broadcaster available");
            }
            // Broadcast our response message which eventually results in the
            // ServerPushHandler's onMessage() method being called. By default
            // broadcast operations of the Atmosphere framework are executed
            // asynchronously (in another thread). But since we don't want to
            // release our lock on the HTTP session before the client was
            // updated, we invoke get() on the returned future and wait for
            // the broadcast operation to complete before we proceed any further.
            broadcaster.broadcast(message).get();

            // Reset state of the reload manager, e.g. clear dirty components.
            reloadManager.clear();
        }
    }

    private Message getUpdateMessage() {
        // The actual update message is generated by utilizing the UpdateResource
        // of the wingS framework - just as it is done for normal client requests.
        UpdateResource updateResource = getUpdateResource();
        if (updateResource != null) {
            try {
                StringBuilderDevice updates = new StringBuilderDevice();
                updateResource.write(updates);
                return new Message(updates.toString(), updateResource.getMimeType());
            } catch (IOException ex) {
                LOG.error("Error while creating update message", ex);
            }
        }
        return null;
    }

    private UpdateResource getUpdateResource() {
        // Get the UpdateResource by taking the first frame inside the session
        // and walking up the frame hierarchy until the root frame is found.
        Set<SFrame> frames = session.getFrames();
        if (frames.isEmpty()) {
            return null;
        }
        SFrame frame = frames.iterator().next();
        while (frame.getParent() != null) {
            frame = (SFrame) frame.getParent();
        }
        return (UpdateResource) frame.getDynamicResource(UpdateResource.class);
    }

    /**
     * A simple wrapper class for a Pushable's response message
     */
    public static class Message {

        private final String content;
        private final String contentType;

        public Message(String content, String contentType) {
            this.content = content;
            this.contentType = contentType;
        }

        public String getContent() {
            return content;
        }

        public String getContentType() {
            return contentType;
        }
    }
}
